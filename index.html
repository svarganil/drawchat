<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Shared Canvas (GitHub Pages + Firebase)</title>
  <style>
    :root { --bg: #fafafa; --ink: #111; }
    html, body { height: 100%; margin: 0; background: var(--bg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
    .wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { padding: 10px 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #e5e5e5; background: white; position: sticky; top: 0; z-index: 1; }
    .spacer { flex: 1; }
    .controls-row { display: flex; gap: 8px; align-items: center; }
    .buttons-row { display: flex; gap: 8px; align-items: center; }
    label { display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; }
    input[type="range"] { width: 80px; }
    button, select, input[type="color"] { border: 1px solid #ddd; background: #fff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 13px; min-height: 36px; touch-action: manipulation; }
    button:hover { border-color: #bbb; }
    input[type="color"] { width: 40px; height: 36px; padding: 2px; cursor: pointer; }
    canvas { display: block; width: 100%; height: calc(100vh - 70px); background: #fff; touch-action: none; }
    /* Support for devices with notches */
    @supports (padding: max(0px)) {
      header { padding-left: max(12px, env(safe-area-inset-left)); padding-right: max(12px, env(safe-area-inset-right)); }
      canvas { height: calc(100vh - 70px - env(safe-area-inset-bottom)); }
    }
    
    /* Tablet and smaller desktop */
    @media (max-width: 768px) {
      html, body { font-size: 13px; }
      header { padding: 8px 10px; gap: 6px; }
      .controls-row { display: flex; gap: 6px; align-items: center; }
      label { font-size: 12px; }
      label span { display: inline; }
      input[type="range"] { width: 60px; }
      button { padding: 10px 14px; font-size: 12px; min-height: 40px; }
      input[type="color"] { width: 44px; height: 40px; }
      .buttons-row { display: flex; gap: 6px; }
      #save { flex: 1.2; }
    }
    
    /* Mobile phones */
    @media (max-width: 480px) {
      header { flex-direction: column; align-items: stretch; padding: 8px; }
      .spacer { display: none; }
      .controls-row { display: flex; gap: 6px; align-items: center; width: 100%; }
      label { flex: 1; min-width: 0; }
      label span { display: none; }
      input[type="range"] { flex: 1; width: auto; min-width: 0; }
      input[type="color"] { width: 44px; flex-shrink: 0; }
      .buttons-row { display: flex; gap: 6px; width: 100%; }
      button { flex: 1; min-width: 0; }
    }
    
    /* Very small screens */
    @media (max-width: 360px) {
      header { padding: 6px; gap: 4px; }
      button { padding: 8px 10px; font-size: 11px; }
      input[type="range"] { width: 50px; }
    }
    
    /* Prevent text selection on buttons during touch */
    button {
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="spacer"></div>
      <div class="controls-row">
        <label><span>Brush:</span> <input id="size" type="range" min="1" max="30" value="6" /></label>
        <input id="color" type="color" value="#111111" />
      </div>
      <div class="buttons-row">
        <button id="clear">Clear</button>
        <button id="save">Guardar</button>
      </div>
    </header>

    <canvas id="board"></canvas>
  </div>

  <!-- App logic: import Firebase directly from CDN (no build tools needed) -->
  <script type="module">
    // ----- 1) Firebase SDKs (v11) from CDN -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
    // Optional: enable anonymous auth if you lock rules
    // import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

    // ----- 2) YOUR Firebase config -----
    // ðŸ”´ Replace with your own values from Firebase Console â†’ Project settings â†’ General â†’ Your apps (Web)
    const firebaseConfig = {
  apiKey: "AIzaSyD-d3WqHcSUc4Nn-lL-WqHTNjrFwlN6el4",
  authDomain: "drawchat-5447f.firebaseapp.com",
  databaseURL: "https://drawchat-5447f-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "drawchat-5447f",
  storageBucket: "drawchat-5447f.firebasestorage.app",
  messagingSenderId: "189484350667",
  appId: "1:189484350667:web:2c58ce4caea115aebaaf4e",
  measurementId: "G-SB8HC1ZQW7"
};

    // ----- 3) Init Firebase -----
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // If you change rules to require auth, uncomment below:
    // const auth = getAuth(app);
    // signInAnonymously(auth).catch(console.error);

    // ----- 4) Canvas setup -----
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      // Save current image before resizing
      let imageData = null;
      try {
        if (canvas.width > 0 && canvas.height > 0) {
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      } catch (e) {
        // Canvas might be empty or not initialized
      }
      
      const header = document.querySelector('header');
      const headerHeight = header ? header.offsetHeight : 70;
      const newWidth = window.innerWidth;
      const newHeight = Math.max(400, window.innerHeight - headerHeight);
      
      // Only resize if dimensions changed
      if (canvas.width !== newWidth || canvas.height !== newHeight) {
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Restore image data if we had any
        if (imageData) {
          try {
            ctx.putImageData(imageData, 0, 0);
          } catch (e) {
            // If restoration fails, try to reload from Firebase
            console.log('Could not restore canvas, will reload from Firebase');
          }
        }
      }
      
      // Ensure crisp lines
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }
    // Handle window resize and orientation changes
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
      // Delay to ensure layout has updated
      setTimeout(resizeCanvas, 100);
    });
    // Use ResizeObserver to watch header size changes
    const header = document.querySelector('header');
    if (header && window.ResizeObserver) {
      new ResizeObserver(resizeCanvas).observe(header);
    }
    // Initial resize
    resizeCanvas();
    // Also resize after a short delay to handle any layout issues
    setTimeout(resizeCanvas, 100);

    const sizeEl = document.getElementById('size');
    const colorEl = document.getElementById('color');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');

    let drawing = false;
    let lastX = 0, lastY = 0;

    function posFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { 
        x: (e.clientX - rect.left) * scaleX, 
        y: (e.clientY - rect.top) * scaleY 
      };
    }
    function posFromTouch(e) {
      e.preventDefault(); // Prevent scrolling
      const t = e.touches[0];
      if (!t) return null;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { 
        x: (t.clientX - rect.left) * scaleX, 
        y: (t.clientY - rect.top) * scaleY 
      };
    }

    function begin(x, y) {
      drawing = true;
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function drawTo(x, y) {
      if (!drawing) return;
      ctx.lineWidth = Number(sizeEl.value);
      ctx.strokeStyle = colorEl.value;
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    }
    function end() { drawing = false; }

    // Prevent context menu on canvas (long press on mobile)
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    // Mouse
    canvas.addEventListener('mousedown', e => { const p = posFromMouse(e); begin(p.x, p.y); });
    canvas.addEventListener('mousemove', e => { const p = posFromMouse(e); drawTo(p.x, p.y); });
    window.addEventListener('mouseup', end);

    // Touch - prevent default to avoid scrolling while drawing
    let lastTouchEnd = 0;
    canvas.addEventListener('touchstart', e => { 
      // Prevent double-tap zoom
      const now = Date.now();
      if (now - lastTouchEnd < 300) {
        e.preventDefault();
      }
      if (e.touches.length === 1) {
        e.preventDefault();
        const p = posFromTouch(e); 
        if (p) begin(p.x, p.y); 
      } else if (e.touches.length > 1) {
        // Prevent zoom on multi-touch
        e.preventDefault();
      }
    }, { passive: false });
    canvas.addEventListener('touchmove', e => { 
      if (e.touches.length === 1 && drawing) {
        e.preventDefault();
        const p = posFromTouch(e); 
        if (p) drawTo(p.x, p.y); 
      } else if (e.touches.length > 1) {
        // Prevent zoom on multi-touch
        e.preventDefault();
      }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
      lastTouchEnd = Date.now();
      e.preventDefault();
      end();
    }, { passive: false });
    canvas.addEventListener('touchcancel', e => {
      e.preventDefault();
      end();
    }, { passive: false });

    // Clear
    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // ----- 5) Load shared image in real time -----
    const docRef = ref(db, 'drawing');
    onValue(docRef, (snap) => {
      const data = snap.val();
      if (data && data.img) {
        const img = new Image();
        img.onload = () => {
          // Clear before drawing the shared image so it matches exactly
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Fit image to canvas preserving aspect (draw full canvas)
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = data.img;
      }
    });

    // ----- 6) Save for everyone (overwrites the single shared image) -----
    saveBtn.addEventListener('click', async () => {
      const dataUrl = canvas.toDataURL('image/png');
      await set(docRef, { img: dataUrl, savedAt: Date.now() });
      saveBtn.textContent = 'Saved!';
      setTimeout(() => (saveBtn.textContent = 'Guardar'), 1200);
    });
  </script>
</body>
</html>
