<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Shared Canvas (GitHub Pages + Firebase)</title>
  <style>
    :root { --bg: #fafafa; --ink: #111; }
    html, body { height: 100%; margin: 0; background: var(--bg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; touch-action: manipulation; }
    .wrap { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { padding: 10px 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #e5e5e5; background: white; position: sticky; top: 0; z-index: 1; }
    .spacer { flex: 1; }
    .controls-row { display: flex; gap: 8px; align-items: center; }
    .buttons-row { display: flex; gap: 8px; align-items: center; }
    label { display: flex; align-items: center; gap: 6px; font-size: 13px; white-space: nowrap; }
    input[type="range"] { width: 80px; }
    button, select, input[type="color"] { border: 1px solid #ddd; background: #fff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 13px; min-height: 36px; touch-action: manipulation; }
    button:hover { border-color: #bbb; }
    input[type="color"] { width: 40px; height: 36px; padding: 2px; cursor: pointer; }
    .canvas-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 70px);
      overflow: hidden;
      background: #f0f0f0;
    }
    canvas { 
      display: block; 
      width: 100%; 
      height: 100%; 
    }
    
    /* Mobile: enable panning with scrollable container */
    @media (max-width: 768px) {
      .canvas-container {
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        position: relative;
        /* Center canvas initially on mobile */
        scroll-behavior: smooth;
        /* Allow scrolling by touching container edges or using two fingers */
        touch-action: pan-x pan-y;
      }
      canvas {
        /* On mobile, canvas takes full logical size, container allows scrolling */
        touch-action: pinch-zoom;
      }
    }
    /* Support for devices with notches */
    @supports (padding: max(0px)) {
      header { padding-left: max(12px, env(safe-area-inset-left)); padding-right: max(12px, env(safe-area-inset-right)); }
      canvas { height: calc(100vh - 70px - env(safe-area-inset-bottom)); }
    }
    
    /* Tablet and smaller desktop */
    @media (max-width: 768px) {
      html, body { font-size: 13px; }
      header { padding: 8px 10px; gap: 6px; }
      .controls-row { display: flex; gap: 6px; align-items: center; }
      label { font-size: 12px; }
      label span { display: inline; }
      input[type="range"] { width: 60px; }
      button { padding: 10px 14px; font-size: 12px; min-height: 40px; }
      input[type="color"] { width: 44px; height: 40px; }
      .buttons-row { display: flex; gap: 6px; }
      #save { flex: 1.2; }
    }
    
    /* Mobile phones */
    @media (max-width: 480px) {
      header { flex-direction: column; align-items: stretch; padding: 8px; }
      .spacer { display: none; }
      .controls-row { display: flex; gap: 6px; align-items: center; width: 100%; }
      label { flex: 1; min-width: 0; }
      label span { display: none; }
      input[type="range"] { flex: 1; width: auto; min-width: 0; }
      input[type="color"] { width: 44px; flex-shrink: 0; }
      .buttons-row { display: flex; gap: 6px; width: 100%; }
      button { flex: 1; min-width: 0; }
    }
    
    /* Very small screens */
    @media (max-width: 360px) {
      header { padding: 6px; gap: 4px; }
      button { padding: 8px 10px; font-size: 11px; }
      input[type="range"] { width: 50px; }
    }
    
    /* Prevent text selection on buttons during touch */
    button {
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="spacer"></div>
      <div class="controls-row">
        <label><span>Brush:</span> <input id="size" type="range" min="1" max="30" value="6" /></label>
        <input id="color" type="color" value="#111111" />
      </div>
      <div class="buttons-row">
        <button id="clear">Clear</button>
        <button id="save">Guardar</button>
      </div>
    </header>

    <div class="canvas-container">
      <canvas id="board"></canvas>
    </div>
  </div>

  <!-- App logic: import Firebase directly from CDN (no build tools needed) -->
  <script type="module">
    // ----- 1) Firebase SDKs (v11) from CDN -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
    // Optional: enable anonymous auth if you lock rules
    // import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

    // ----- 2) YOUR Firebase config -----
    // ðŸ”´ Replace with your own values from Firebase Console â†’ Project settings â†’ General â†’ Your apps (Web)
    const firebaseConfig = {
  apiKey: "AIzaSyD-d3WqHcSUc4Nn-lL-WqHTNjrFwlN6el4",
  authDomain: "drawchat-5447f.firebaseapp.com",
  databaseURL: "https://drawchat-5447f-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "drawchat-5447f",
  storageBucket: "drawchat-5447f.firebasestorage.app",
  messagingSenderId: "189484350667",
  appId: "1:189484350667:web:2c58ce4caea115aebaaf4e",
  measurementId: "G-SB8HC1ZQW7"
};

    // ----- 3) Init Firebase -----
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // If you change rules to require auth, uncomment below:
    // const auth = getAuth(app);
    // signInAnonymously(auth).catch(console.error);

    // ----- 4) Canvas setup -----
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    
    // Fixed canvas resolution for consistency across all devices
    const CANVAS_LOGICAL_WIDTH = 1920;
    const CANVAS_LOGICAL_HEIGHT = 1080;
    
    // Tile pattern image
    let tilePattern = null;
    let tileImage = null;
    let isTileLoaded = false;
    
    // Function to load tile image and create pattern
    function loadTilePattern(callback) {
      if (isTileLoaded && tilePattern && tileImage && tileImage.complete) {
        if (callback) callback();
        return;
      }
      
      // If image is already loading or loaded, wait for it
      if (tileImage && !tileImage.complete) {
        tileImage.onload = () => {
          if (canvas.width > 0 && canvas.height > 0) {
            tilePattern = ctx.createPattern(tileImage, 'repeat');
            isTileLoaded = true;
            if (callback) callback();
          }
        };
        return;
      }
      
      // Load the image
      tileImage = new Image();
      tileImage.onload = () => {
        // Create a repeating pattern from the tile image
        // Need to create pattern after canvas is initialized
        if (canvas.width > 0 && canvas.height > 0) {
          tilePattern = ctx.createPattern(tileImage, 'repeat');
          isTileLoaded = true;
          if (callback) callback();
        } else {
          // Canvas not ready yet, callback will be called when canvas is initialized
          if (callback) callback();
        }
      };
      tileImage.onerror = () => {
        console.error('Failed to load tile image from assets/tile.jpg');
        isTileLoaded = false;
        tilePattern = null;
        if (callback) callback();
      };
      tileImage.src = 'assets/tile.jpg';
    }
    
    // Function to draw tile pattern background (synchronous, assumes pattern is loaded)
    function drawTilePattern() {
      if (tilePattern && isTileLoaded) {
        // Fill entire canvas with the tile pattern
        ctx.fillStyle = tilePattern;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        // Fallback: draw a simple background color if tile fails or not loaded yet
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // Store current drawing as ImageData for restoration
    let currentDrawing = null;
    
    function saveCurrentDrawing() {
      try {
        if (canvas.width > 0 && canvas.height > 0) {
          currentDrawing = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      } catch (e) {
        // Canvas might be empty
      }
    }
    
    function restoreCurrentDrawing() {
      if (currentDrawing) {
        try {
          ctx.putImageData(currentDrawing, 0, 0);
        } catch (e) {
          console.log('Could not restore drawing');
        }
      }
    }
    
    let isCanvasInitialized = false;
    
    function resizeCanvas() {
      const header = document.querySelector('header');
      const headerHeight = header ? header.offsetHeight : 70;
      const displayWidth = window.innerWidth;
      const displayHeight = Math.max(400, window.innerHeight - headerHeight);
      const isMobile = window.innerWidth <= 768;
      
      // Initialize canvas with fixed logical resolution only once
      if (!isCanvasInitialized) {
        // Set fixed logical resolution (internal canvas size)
        canvas.width = CANVAS_LOGICAL_WIDTH;
        canvas.height = CANVAS_LOGICAL_HEIGHT;
        
        // Load tile pattern and draw background
        loadTilePattern(() => {
          // Redraw pattern once image is loaded
          if (isTileLoaded) {
            drawTilePattern();
            saveCurrentDrawing();
          }
        });
        // Draw immediately (fallback if tile not loaded yet - will show gray background)
        drawTilePattern();
        saveCurrentDrawing();
        
        isCanvasInitialized = true;
        
        // Center canvas on mobile devices after initialization
        if (isMobile) {
          setTimeout(() => {
            const container = document.querySelector('.canvas-container');
            if (container) {
              const scrollX = (CANVAS_LOGICAL_WIDTH - container.clientWidth) / 2;
              const scrollY = (CANVAS_LOGICAL_HEIGHT - container.clientHeight) / 2;
              container.scrollTo({
                left: Math.max(0, scrollX),
                top: Math.max(0, scrollY),
                behavior: 'auto'
              });
            }
          }, 200);
        }
      }
      
      // Set display size based on device type
      if (isMobile) {
        // On mobile: show canvas at full logical size for panning
        canvas.style.width = CANVAS_LOGICAL_WIDTH + 'px';
        canvas.style.height = CANVAS_LOGICAL_HEIGHT + 'px';
      } else {
        // On desktop: fit to viewport
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
      }
      
      // Ensure crisp lines (set once, but safe to set multiple times)
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    // Handle window resize and orientation changes
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
      // Delay to ensure layout has updated
      setTimeout(resizeCanvas, 100);
    });
    // Use ResizeObserver to watch header size changes
    const header = document.querySelector('header');
    if (header && window.ResizeObserver) {
      new ResizeObserver(resizeCanvas).observe(header);
    }
    // Start loading tile pattern early
    loadTilePattern();
    
    // Initial resize
    resizeCanvas();
    // Also resize after a short delay to handle any layout issues
    setTimeout(resizeCanvas, 100);

    const sizeEl = document.getElementById('size');
    const colorEl = document.getElementById('color');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');

    let drawing = false;
    let lastX = 0, lastY = 0;

    function posFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x = (e.clientX - rect.left) * scaleX;
      let y = (e.clientY - rect.top) * scaleY;
      // Clamp coordinates to canvas bounds
      x = Math.max(0, Math.min(canvas.width, x));
      y = Math.max(0, Math.min(canvas.height, y));
      return { x, y };
    }
    function posFromTouch(e) {
      e.preventDefault(); // Prevent scrolling
      const t = e.touches[0];
      if (!t) return null;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x = (t.clientX - rect.left) * scaleX;
      let y = (t.clientY - rect.top) * scaleY;
      // Clamp coordinates to canvas bounds
      x = Math.max(0, Math.min(canvas.width, x));
      y = Math.max(0, Math.min(canvas.height, y));
      return { x, y };
    }

    function begin(x, y) {
      drawing = true;
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function drawTo(x, y) {
      if (!drawing) return;
      ctx.lineWidth = Number(sizeEl.value);
      ctx.strokeStyle = colorEl.value;
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    }
    function end() { 
      drawing = false;
      // Update stored drawing after each stroke
      saveCurrentDrawing();
    }

    // Prevent context menu on canvas (long press on mobile)
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    // Mouse
    canvas.addEventListener('mousedown', e => { const p = posFromMouse(e); begin(p.x, p.y); });
    canvas.addEventListener('mousemove', e => { const p = posFromMouse(e); drawTo(p.x, p.y); });
    window.addEventListener('mouseup', end);

    // Touch handling: one finger = drawing on canvas, container allows scrolling for panning
    let lastTouchEnd = 0;
    const isMobileDevice = () => window.innerWidth <= 768;
    
    canvas.addEventListener('touchstart', e => { 
      // Two fingers = allow panning (scrolling container)
      if (e.touches.length === 2) {
        drawing = false;
        // Allow default scrolling behavior for panning
        return;
      }
      
      // One finger on canvas = drawing mode
      if (e.touches.length === 1) {
        // Prevent scrolling while drawing to get accurate coordinates
        e.preventDefault();
        const p = posFromTouch(e); 
        if (p) {
          begin(p.x, p.y);
        }
      }
      
      // Prevent double-tap zoom
      const now = Date.now();
      if (now - lastTouchEnd < 300 && e.touches.length === 1) {
        e.preventDefault();
      }
    }, { passive: false });
    
    canvas.addEventListener('touchmove', e => { 
      // Two fingers = allow panning (scrolling)
      if (e.touches.length === 2) {
        drawing = false;
        // Don't prevent default - allow scrolling
        return;
      }
      
      // One finger = drawing
      if (e.touches.length === 1 && drawing) {
        e.preventDefault(); // Prevent scrolling while drawing
        const p = posFromTouch(e); 
        if (p) drawTo(p.x, p.y);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', e => {
      lastTouchEnd = Date.now();
      
      // End drawing if we were drawing
      if (drawing && e.touches.length === 0) {
        end();
      }
    }, { passive: false });
    
    canvas.addEventListener('touchcancel', e => {
      drawing = false;
      e.preventDefault();
    }, { passive: false });

    // Clear - redraw tile pattern
    clearBtn.addEventListener('click', () => {
      drawTilePattern();
      saveCurrentDrawing();
    });

    // ----- 5) Load shared image in real time -----
    const docRef = ref(db, 'drawing');
    
    onValue(docRef, (snap) => {
      const data = snap.val();
      if (data && data.img) {
        const img = new Image();
        img.onload = () => {
          // Canvas should be initialized by resizeCanvas() by now
          // But ensure it's initialized just in case
          if (!isCanvasInitialized) {
            resizeCanvas();
          }
          
          // Ensure tile pattern is loaded before drawing
          if (!isTileLoaded) {
            loadTilePattern(() => {
              drawTilePattern();
              // Scale and draw the shared image to fit fixed canvas resolution
              ctx.drawImage(img, 0, 0, CANVAS_LOGICAL_WIDTH, CANVAS_LOGICAL_HEIGHT);
              saveCurrentDrawing();
            });
          } else {
            // Always draw tile pattern first (for transparency support and consistency)
            drawTilePattern();
            
            // Scale and draw the shared image to fit fixed canvas resolution
            // This ensures consistent size across all devices, regardless of original image size
            // The image will be scaled to exactly match our fixed resolution (1920x1080)
            ctx.drawImage(img, 0, 0, CANVAS_LOGICAL_WIDTH, CANVAS_LOGICAL_HEIGHT);
            
            // Update stored drawing
            saveCurrentDrawing();
          }
        };
        img.onerror = () => {
          // If image fails to load, ensure canvas is initialized with tile pattern
          if (!isCanvasInitialized) {
            resizeCanvas();
          } else {
            drawTilePattern();
            saveCurrentDrawing();
          }
        };
        img.src = data.img;
      }
      // If no image in database, canvas will show tile pattern from initial resizeCanvas() call
    });

    // ----- 6) Save for everyone (overwrites the single shared image) -----
    saveBtn.addEventListener('click', async () => {
      // Save at fixed resolution to ensure consistency
      // Canvas is already at fixed resolution, so we can save directly
      const dataUrl = canvas.toDataURL('image/png');
      await set(docRef, { img: dataUrl, savedAt: Date.now() });
      saveBtn.textContent = 'Saved!';
      setTimeout(() => (saveBtn.textContent = 'Guardar'), 1200);
    });
  </script>
</body>
</html>
