<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Shared Canvas (GitHub Pages + Firebase)</title>
  <style>
    :root { --bg: #fafafa; --ink: #111; }
    html, body { height: 100%; margin: 0; background: var(--bg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; touch-action: manipulation; }
    .wrap { position: relative; height: 100%; }
    .menu-toggle {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      border: 1px solid #ddd;
      background: #fff;
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      min-height: 40px;
      touch-action: manipulation;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
    }
    .menu-toggle.active {
      background: var(--ink);
      color: #fff;
      border-color: var(--ink);
    }
    .clear-button {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 9;
      transform: translateX(-120%);
      opacity: 0;
      pointer-events: none;
      border: 1px solid #ddd;
      background: #fff;
      padding: 10px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      min-height: 40px;
      touch-action: manipulation;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1);
      transition: transform 0.25s ease, opacity 0.25s ease;
    }
    .clear-button:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }
    body.draw-mode .clear-button {
      transform: translateX(64px);
      opacity: 1;
      pointer-events: auto;
    }
    .menu-toggle:hover,
    body.draw-mode .clear-button:hover {
      border-color: #bbb;
    }
    .canvas-container {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: auto;
      background: #f0f0f0;
      -webkit-overflow-scrolling: touch;
      cursor: grab;
    }
    .canvas-container.is-panning,
    canvas.is-panning {
      cursor: grabbing;
    }
    body.pan-mode .canvas-container {
      cursor: grab;
    }
    body.pan-mode .canvas-container.is-panning {
      cursor: grabbing;
    }
    canvas { 
      display: block; 
    }
    @media (max-width: 480px) {
      .menu-toggle,
      .clear-button {
        top: 12px;
        left: 12px;
        min-height: 38px;
        padding: 9px 12px;
        font-size: 16px;
      }
      body.draw-mode .clear-button {
        transform: translateX(56px);
      }
    }
    
    /* Mobile: enable panning with scrollable container */
    @media (max-width: 768px) {
      .canvas-container {
        overscroll-behavior: contain;
        position: relative;
        /* Center canvas initially on mobile */
        scroll-behavior: smooth;
        /* Allow scrolling by touching container edges or using two fingers */
        touch-action: pan-x pan-y;
      }
      canvas {
        /* On mobile, canvas takes full logical size, container allows scrolling */
        touch-action: pinch-zoom;
      }
    }
    /* Support for devices with notches */
    @supports (padding: max(0px)) {
      .menu-toggle,
      .clear-button {
        top: max(12px, env(safe-area-inset-top));
        left: max(12px, env(safe-area-inset-left));
      }
      .canvas-container {
        padding-bottom: env(safe-area-inset-bottom);
      }
    }
    
    /* Prevent text selection on buttons during touch */
    button {
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <button id="toggleMenu" class="menu-toggle" type="button" aria-pressed="false" aria-label="–ù–∞—á–∞—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏–µ">‚úèÔ∏è</button>
    <button id="clear" class="clear-button" type="button" aria-label="–û—á–∏—Å—Ç–∏—Ç—å —Ö–æ–ª—Å—Ç" disabled>üßΩ</button>
    <div class="canvas-container">
      <canvas id="board"></canvas>
    </div>
  </div>

  <!-- App logic: import Firebase directly from CDN (no build tools needed) -->
  <script type="module">
    // ----- 1) Firebase SDKs (v11) from CDN -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
    // Optional: enable anonymous auth if you lock rules
    // import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

    // ----- 2) YOUR Firebase config -----
    // üî¥ Replace with your own values from Firebase Console ‚Üí Project settings ‚Üí General ‚Üí Your apps (Web)
    const firebaseConfig = {
  apiKey: "AIzaSyD-d3WqHcSUc4Nn-lL-WqHTNjrFwlN6el4",
  authDomain: "drawchat-5447f.firebaseapp.com",
  databaseURL: "https://drawchat-5447f-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "drawchat-5447f",
  storageBucket: "drawchat-5447f.firebasestorage.app",
  messagingSenderId: "189484350667",
  appId: "1:189484350667:web:2c58ce4caea115aebaaf4e",
  measurementId: "G-SB8HC1ZQW7"
};

    // ----- 3) Init Firebase -----
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // If you change rules to require auth, uncomment below:
    // const auth = getAuth(app);
    // signInAnonymously(auth).catch(console.error);

    // ----- 4) Canvas setup -----
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const container = document.querySelector('.canvas-container');
    
    // Fixed canvas resolution for consistency across all devices
    const CANVAS_LOGICAL_WIDTH = 3840;
    const CANVAS_LOGICAL_HEIGHT = 2160;
    const BRUSH_COLOR = '#111111';
    const BRUSH_SIZE = 6;
    
    // Tile pattern image
    let tilePattern = null;
    let tileImage = null;
    let isTileLoaded = false;
    
    // Function to load tile image and create pattern
    function loadTilePattern(callback) {
      if (isTileLoaded && tilePattern && tileImage && tileImage.complete) {
        if (callback) callback();
        return;
      }
      
      // If image is already loading or loaded, wait for it
      if (tileImage && !tileImage.complete) {
        tileImage.onload = () => {
          if (canvas.width > 0 && canvas.height > 0) {
            tilePattern = ctx.createPattern(tileImage, 'repeat');
            isTileLoaded = true;
            if (callback) callback();
          }
        };
        return;
      }
      
      // Load the image
      tileImage = new Image();
      tileImage.onload = () => {
        // Create a repeating pattern from the tile image
        // Need to create pattern after canvas is initialized
        if (canvas.width > 0 && canvas.height > 0) {
          tilePattern = ctx.createPattern(tileImage, 'repeat');
          isTileLoaded = true;
          if (callback) callback();
        } else {
          // Canvas not ready yet, callback will be called when canvas is initialized
          if (callback) callback();
        }
      };
      tileImage.onerror = () => {
        console.error('Failed to load tile image from assets/tile.jpg');
        isTileLoaded = false;
        tilePattern = null;
        if (callback) callback();
      };
      tileImage.src = 'assets/tile.jpg';
    }
    
    // Function to draw tile pattern background (synchronous, assumes pattern is loaded)
    function drawTilePattern() {
      if (tilePattern && isTileLoaded) {
        // Fill entire canvas with the tile pattern
        ctx.fillStyle = tilePattern;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        // Fallback: draw a simple background color if tile fails or not loaded yet
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    // Store current drawing as ImageData for restoration
    let currentDrawing = null;
    
    function saveCurrentDrawing() {
      try {
        if (canvas.width > 0 && canvas.height > 0) {
          currentDrawing = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      } catch (e) {
        // Canvas might be empty
      }
    }
    
    function restoreCurrentDrawing() {
      if (currentDrawing) {
        try {
          ctx.putImageData(currentDrawing, 0, 0);
        } catch (e) {
          console.log('Could not restore drawing');
        }
      }
    }
    
    let isCanvasInitialized = false;
    let hasCenteredView = false;
    let isPanning = false;
    let isSpacePressed = false;
    let drawingEnabled = false;
    let panStartX = 0;
    let panStartY = 0;
    let panScrollLeft = 0;
    let panScrollTop = 0;

    function centerCanvasView() {
      if (!container) return;
      const scrollX = Math.max(0, (canvas.clientWidth - container.clientWidth) / 2);
      const scrollY = Math.max(0, (canvas.clientHeight - container.clientHeight) / 2);
      container.scrollTo({
        left: scrollX,
        top: scrollY,
        behavior: 'auto'
      });
    }

    function startPan(clientX, clientY) {
      if (!container) return;
      isPanning = true;
      panStartX = clientX;
      panStartY = clientY;
      panScrollLeft = container.scrollLeft;
      panScrollTop = container.scrollTop;
      container.classList.add('is-panning');
      canvas.classList.add('is-panning');
    }

    function updatePan(clientX, clientY) {
      if (!isPanning || !container) return;
      const dx = clientX - panStartX;
      const dy = clientY - panStartY;
      container.scrollTo({
        left: panScrollLeft - dx,
        top: panScrollTop - dy,
        behavior: 'auto'
      });
    }

    function endPan() {
      if (!isPanning) return;
      isPanning = false;
      container.classList.remove('is-panning');
      canvas.classList.remove('is-panning');
    }

    function getTouchMidpoint(touches) {
      if (!touches || touches.length === 0) return null;
      let sumX = 0;
      let sumY = 0;
      for (let i = 0; i < touches.length; i++) {
        sumX += touches[i].clientX;
        sumY += touches[i].clientY;
      }
      return {
        x: sumX / touches.length,
        y: sumY / touches.length
      };
    }
    
    function resizeCanvas() {
      if (container) {
        const containerHeight = Math.max(400, window.innerHeight);
        container.style.height = containerHeight + 'px';
      }

      // Initialize canvas with fixed logical resolution only once
      if (!isCanvasInitialized) {
        // Set fixed logical resolution (internal canvas size)
        canvas.width = CANVAS_LOGICAL_WIDTH;
        canvas.height = CANVAS_LOGICAL_HEIGHT;
        
        // Load tile pattern and draw background
        loadTilePattern(() => {
          // Redraw pattern once image is loaded
          if (isTileLoaded) {
            drawTilePattern();
            saveCurrentDrawing();
          }
        });
        // Draw immediately (fallback if tile not loaded yet - will show gray background)
        drawTilePattern();
        saveCurrentDrawing();
        
        isCanvasInitialized = true;
        
        // Center canvas within the viewport after initialization
        setTimeout(() => {
          centerCanvasView();
          hasCenteredView = true;
        }, 200);
      }
      
      // Ensure display size always reflects the full logical canvas
      canvas.style.width = CANVAS_LOGICAL_WIDTH + 'px';
      canvas.style.height = CANVAS_LOGICAL_HEIGHT + 'px';
      
      // Ensure crisp lines (set once, but safe to set multiple times)
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    // Handle window resize and orientation changes
    window.addEventListener('resize', () => {
      resizeCanvas();
      if (!hasCenteredView) {
        centerCanvasView();
        hasCenteredView = true;
      }
    });
    window.addEventListener('orientationchange', () => {
      // Delay to ensure layout has updated
      setTimeout(resizeCanvas, 100);
      hasCenteredView = false;
      setTimeout(() => {
        centerCanvasView();
        hasCenteredView = true;
      }, 200);
    });
    // Start loading tile pattern early
    loadTilePattern();
    
    // Initial resize
    resizeCanvas();
    // Also resize after a short delay to handle any layout issues
    setTimeout(resizeCanvas, 100);

    const menuBtn = document.getElementById('toggleMenu');
    const clearBtn = document.getElementById('clear');
    const MENU_ICON = '‚úèÔ∏è';
    const SAVE_ICON = 'üíæ';

    let drawing = false;
    let lastX = 0, lastY = 0;
    let saveFeedbackTimeout = null;

    function setDrawingEnabled(enabled) {
      const wasEnabled = drawingEnabled;
      drawingEnabled = enabled;
      document.body.classList.toggle('draw-mode', enabled);
      if (menuBtn) {
        menuBtn.classList.toggle('active', enabled);
        menuBtn.setAttribute('aria-pressed', String(enabled));
        menuBtn.setAttribute('aria-label', enabled ? '–ó–∞–∫–æ–Ω—á–∏—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å' : '–ù–∞—á–∞—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏–µ');
        if (enabled) {
          menuBtn.textContent = MENU_ICON;
          if (saveFeedbackTimeout) {
            clearTimeout(saveFeedbackTimeout);
            saveFeedbackTimeout = null;
          }
        }
      }
      if (clearBtn) {
        clearBtn.disabled = !enabled;
      }
      if (!enabled) {
        if (drawing) {
          end();
        }
        drawing = false;
      }
      if (!enabled && wasEnabled) {
        saveDrawing()
          .then(() => {
            if (menuBtn) {
              menuBtn.textContent = SAVE_ICON;
              if (saveFeedbackTimeout) {
                clearTimeout(saveFeedbackTimeout);
              }
              saveFeedbackTimeout = setTimeout(() => {
                menuBtn.textContent = MENU_ICON;
                saveFeedbackTimeout = null;
              }, 1200);
            }
          })
          .catch(console.error);
      }
    }

    setDrawingEnabled(false);

    if (menuBtn) {
      menuBtn.addEventListener('click', () => {
        setDrawingEnabled(!drawingEnabled);
      });
    }

    function posFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x = (e.clientX - rect.left) * scaleX;
      let y = (e.clientY - rect.top) * scaleY;
      // Clamp coordinates to canvas bounds
      x = Math.max(0, Math.min(canvas.width, x));
      y = Math.max(0, Math.min(canvas.height, y));
      return { x, y };
    }
    function posFromTouch(e) {
      e.preventDefault(); // Prevent scrolling
      const t = e.touches[0];
      if (!t) return null;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let x = (t.clientX - rect.left) * scaleX;
      let y = (t.clientY - rect.top) * scaleY;
      // Clamp coordinates to canvas bounds
      x = Math.max(0, Math.min(canvas.width, x));
      y = Math.max(0, Math.min(canvas.height, y));
      return { x, y };
    }

    function begin(x, y) {
      if (!drawingEnabled) {
        drawing = false;
        return;
      }
      drawing = true;
      lastX = x; lastY = y;
      ctx.beginPath();
      ctx.lineWidth = BRUSH_SIZE;
      ctx.strokeStyle = BRUSH_COLOR;
      ctx.moveTo(x, y);
    }
    function drawTo(x, y) {
      if (!drawing || !drawingEnabled) return;
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    }
    function end() { 
      if (!drawing) return;
      drawing = false;
      // Update stored drawing after each stroke
      saveCurrentDrawing();
    }

    // Prevent context menu on canvas (long press on mobile)
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    // Mouse
    window.addEventListener('keydown', e => {
      if (e.code === 'Space' && !isSpacePressed) {
        isSpacePressed = true;
        document.body.classList.add('pan-mode');
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'Space') {
        isSpacePressed = false;
        document.body.classList.remove('pan-mode');
      }
    });

    canvas.addEventListener('mousedown', e => {
      const panGesture = !drawingEnabled || isSpacePressed || e.button === 1 || e.button === 2;
      if (panGesture) {
        if (e.button === 0 || e.button === 1 || e.button === 2) {
          e.preventDefault();
          drawing = false;
          startPan(e.clientX, e.clientY);
        }
        return;
      }
      if (e.button !== 0) return;
      const p = posFromMouse(e);
      begin(p.x, p.y);
    });
    canvas.addEventListener('mousemove', e => { 
      if (isPanning || !drawingEnabled) return;
      const p = posFromMouse(e); 
      drawTo(p.x, p.y); 
    });
    window.addEventListener('mousemove', e => {
      if (!isPanning) return;
      e.preventDefault();
      updatePan(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', () => {
      if (isPanning) {
        endPan();
      }
      if (drawing) {
        end();
      }
    });

    // Touch handling: tools button toggles drawing; single-finger pans when drawing disabled
    let lastTouchEnd = 0;
    canvas.addEventListener('touchstart', e => { 
      const shouldPan = !drawingEnabled || e.touches.length >= 2;
      if (shouldPan) {
        drawing = false;
        const midpoint = getTouchMidpoint(e.touches);
        if (midpoint) {
          e.preventDefault();
          startPan(midpoint.x, midpoint.y);
        }
        return;
      }

      if (e.touches.length === 1) {
        e.preventDefault();
        const p = posFromTouch(e); 
        if (p) {
          begin(p.x, p.y);
        }
      }

      const now = Date.now();
      if (now - lastTouchEnd < 300 && e.touches.length === 1) {
        e.preventDefault();
      }
    }, { passive: false });
    
    canvas.addEventListener('touchmove', e => { 
      if (isPanning) {
        e.preventDefault();
        const midpoint = getTouchMidpoint(e.touches);
        if (midpoint) {
          updatePan(midpoint.x, midpoint.y);
        }
        return;
      }
      
      if (e.touches.length === 1 && drawing) {
        e.preventDefault();
        const p = posFromTouch(e); 
        if (p) drawTo(p.x, p.y);
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', e => {
      lastTouchEnd = Date.now();
      
      if (isPanning && e.touches.length === 0) {
        endPan();
      }
      
      // End drawing if we were drawing
      if (drawing && e.touches.length === 0) {
        end();
      }
    }, { passive: false });
    
    canvas.addEventListener('touchcancel', e => {
      drawing = false;
      if (isPanning) {
        endPan();
      }
      e.preventDefault();
    }, { passive: false });

    // Clear - redraw tile pattern
    if (clearBtn) {
      clearBtn.addEventListener('click', () => {
        drawTilePattern();
        saveCurrentDrawing();
      });
    }

    // ----- 5) Load shared image in real time -----
    const docRef = ref(db, 'drawing');
    
    async function saveDrawing() {
      try {
        const dataUrl = canvas.toDataURL('image/png');
        await set(docRef, { img: dataUrl, savedAt: Date.now() });
      } catch (error) {
        console.error('Failed to save drawing', error);
      }
    }

    onValue(docRef, (snap) => {
      const data = snap.val();
      if (data && data.img) {
        const img = new Image();
        img.onload = () => {
          // Canvas should be initialized by resizeCanvas() by now
          // But ensure it's initialized just in case
          if (!isCanvasInitialized) {
            resizeCanvas();
          }
          
          // Ensure tile pattern is loaded before drawing
          if (!isTileLoaded) {
            loadTilePattern(() => {
              drawTilePattern();
              // Scale and draw the shared image to fit fixed canvas resolution
              ctx.drawImage(img, 0, 0, CANVAS_LOGICAL_WIDTH, CANVAS_LOGICAL_HEIGHT);
              saveCurrentDrawing();
            });
          } else {
            // Always draw tile pattern first (for transparency support and consistency)
            drawTilePattern();
            
            // Scale and draw the shared image to fit fixed canvas resolution
            // This ensures consistent size across all devices, regardless of original image size
            // The image will be scaled to exactly match our fixed resolution (1920x1080)
            ctx.drawImage(img, 0, 0, CANVAS_LOGICAL_WIDTH, CANVAS_LOGICAL_HEIGHT);
            
            // Update stored drawing
            saveCurrentDrawing();
          }
        };
        img.onerror = () => {
          // If image fails to load, ensure canvas is initialized with tile pattern
          if (!isCanvasInitialized) {
            resizeCanvas();
          } else {
            drawTilePattern();
            saveCurrentDrawing();
          }
        };
        img.src = data.img;
      }
      // If no image in database, canvas will show tile pattern from initial resizeCanvas() call
    });
  </script>
</body>
</html>
